#!/usr/bin/env - python

'''Extract files from message/partial MIME messages generated by NRG MP 161 scanfax appliances.
See  http://blogs.23.nu/c0re/2008/11/departicularifier-for-nrg-mp-161-scanfaxprinter/ for further details.

Created 2008-11-01 by Maximillian Dornseif. You may consider it BSD licensed.'''

import email
import mimetypes
import getpass
import os
import sys
import imaplib
from optparse import OptionParser


__revision__ = '$Revision: 3958 $'


parser = OptionParser(version=True)
parser.version = "%%prog %s" % (__revision__.strip('$Revision: '))
parser.description = __doc__

parser.set_usage('usage: %prog --user=you@example.com [options].\nTry %prog --help for details.')
parser.add_option('--server', action='store', type='string', default='mail.hudora.biz',
                  help='hostname of the IMAPS server where the messages are stored (default: "%default")')
parser.add_option('--user', action='store', type='string',
                  help='User name for logging into the server (default: "%default")')
parser.add_option('--password', action='store', type='string', default=0,
                  help='Pasword used to login (default: ask for password)')
parser.add_option('--folder', action='store', type='string', default="INBOX",
                  help='Folder to scann for messages (default: "%default")')
parser.add_option('--sender', action='store', type='string', default='scanner@',
                  help='Sender whose messages to process (default: "%default")')
parser.add_option('--dir', action='store', type='string', default='.',
                  help='Destination directory (default: "%default")')


options, args = parser.parse_args()

if not options.user:
    print "username not set"
    sys.exit(1)
if not options.password:
    print "connecting to %r as %r." % (options.server, options.user)
    options.password = getpass.getpass()

M = imaplib.IMAP4_SSL(options.server)
M.login(options.user, options.password)
M.select(options.folder, readonly=True)

typ, messagenums = M.search(None, '(FROM "%s")' % options.sender)

fileparts = {}

for num in messagenums[0].split():
    typ, msg_data = M.fetch(num, '(RFC822)')
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            msg = email.message_from_string(response_part[1])
            if msg.get_content_type() == 'message/partial':
                msginfo = dict(msg.get_params('content-type'))
                if msginfo['id'] not in fileparts:
                    fileparts[msginfo['id']] = [''] * int(msginfo['total'])
                fileparts[msginfo['id']][int(msginfo['number'])-1] = msg.get_payload()[0]
            
            sys.stdout.write('%s %s\r' % ( msg['message-id'], msg['subject']),)
            sys.stdout.flush()
    
print

for fileid in fileparts.keys():
    combined = []
    for part in fileparts[fileid]:
        boundary = dict(msg.get_params('content-type')).get('boundary', None)
        if hasattr(part, 'as_string'):
            text = part.as_string()
        else:
            text = str(part)
        if boundary:
            text = text.strip('\r\n') # .strip('--%s--' % boundary).strip('\r\n')
        combined.append(text)
    
    open(fileid,'w').write(''.join(combined))
    msg = email.message_from_string(''.join(combined))
    
    counter = 0
    for part in msg.walk():
            # multipart/* are just containers
            if part.get_content_maintype() == 'multipart':
                continue
            if part['content-disposition'] and part['content-disposition'].startswith('attachment'):
                filename = part.get_filename()
                if not filename:
                    ext = mimetypes.guess_extension(part.get_content_type())
                    if not ext:
                        ext = '.bin'
                    filename = 'part-%03d%s' % (counter, ext)
                counter += 1
                filename = filename.replace('/', '_')
                filename = os.path.join(options.dir, filename)
                print "writing %s" % (filename,)
                fp = open(filename, 'wb')
                fp.write(part.get_payload(decode=True))
                fp.close()
            
